Technology is often seen as a linear development, towards an ideal of seamless expression, where technology efficiently brings ideas into the world. However, much work in electronic music picks at those seams, stripping back interface design to reveal the systems within. At this moment, we enjoy huge resurgence of interest in modular synthesis, and more generally in maker culture, with great emphasis on revealing how things understanding work, and how they can be repurposed or rebuilt. In electronic music, the state of the art is now not necessarily in the 'fastest' machines, but in the most 'hackable' (Zappi and McPherson, 2014).

Live coding, as a musical practice, has emerged into electronic music culture over the past 16 years. Its history is complicated by emerging from at least three places at once; from the SuperCollider community following the release of version 3.0, where language was decoupled from synthesis, providing grounds for the 'Just-in-Time' environment (JITLib) by Julian Rohrhuber. It also emerged from the work of Ge Wang on ChucK, supporting 'on-the-fly' programming (Wang and Cook, 2003). A third location was the band Slub (of which I am a member), who from the start worked towards writing code while people danced to it, realised through the production of various handmade livecoding environments including MAP/MSG, Pure Events, feedback.pl, Fluxus and Tidal. There were many further precedents, but the exact chronology of these developments is perhaps less interesting than the fact that this burst of activity took place over a few years, from the year 2000. It seems that at this time, there was something 'in the air', a faultline running through assumptions of how software should be made and used in the arts.

That live coding arose from several unconnected places at once hints at technological determinism. But what could this mean, where the artists themselves are creating the technology, and where that technology appears to be almost Luddite in unravelling modern interface paradigms? Furthermore, is it possible to break out of a linear perspective of technology entirely, looking at ancient patterning systems such as the warp weighted loom, to reappraise the role of the human in digital technology?
Through reflection on participating in the AHRC Weaving Codes, Coding Weaves project, and on sixteen years of live coding practice, as well as surveying members from the early live coding community, the author both explores what a history of Live Coding might look like, and how live coding practice challenges the history of computation in general.

Collins, N. and A. McLean (2014). Algorave: A survey of the history, aesthetics and technology of live performance of algorithmic electronic dance music. In Proceedings of the International Conference on New Interfaces for Musical Expression.

Zappi, 	V., and A. McPherson. "Design and use of a hackable digital instrument." (2014).
Wang, Ge, and Perry R. Cook. "ChucK: A concurrent, on-the-fly audio programming language." In Proceedings of International Computer Music Conference, pp. 219-226. 2003.

Rohrhuber, Julian, Alberto de Campo, and Renate Wieser. "Algorithms today notes on language design for just in time programming." context 1 (2005): 291.


Ge: For me, I started working on ChucK in 2002 (shortly after I got to Princeton as as PhD student), partially with the idea to make it an "on-the-fly" language -- reflecting both a personal preference to make things real-time when possible, and an aesthetic curiosity about programming languages that can be used in a "build it as you run it" manner. The temporal determinism and concurrency mechanisms also came about as explorations into designing ChucK, somewhat independently of on-the-fly, although they certainly influence how one live codes in ChucK.  The interest in real-time (and an "hyper" real-time awareness that seems to accompany live programming) can be traced to undergrad where I wrote a lot of real-time graphics and some music/audio software, which in turn may have been from engaging with both musical instruments and video games (two very real-time interactions) since a young age.

Julian: interesting question, about the air. Isn’t it always afterwards, that you recognise what you should have found obvious? In any case, looking back, it is indeed rather strange that live coding, and even simply interactive programming, wasn’t obvious at all. A bit of history we have written down for the Dagstuhl publication, and also the first readme paper has some clues, but maybe together we find a trace of what was it that made it all occur about around that same time.

I have to admit that for me, the basic idea came through a misunderstanding. Some time in the nineties, I visited Iannis Zannos’ lab, and he showed me supercollider: a terse little formula that made a pure sine tone fascinated me indefinitely. After a year or so, I started to write programs on paper, because I had no computer. I finally got supercollider in 1997, and when I had running in the lab of the art academy, I was perhaps a little overly delighted by the possibility of actually writing programs, and misread the readme that said somewhere (I dug it up now): “You can read and compile text at runtime.” I thought that this meant that changes in code would be reflected in changes in sound, so that you could “play" the text. Despite my interest in math and sound, I had not the slightest software engineering background, otherwise I would have understood what it really meant.

While you couldn’t program live, as we understand it today, with the initial versions of sc2, the particular computer science tradition which it inherited (literate programming, REPL etc.) was a strong impulse in this direction. The idea of taking code as interface somehow wasn’t generally self-evident nevertheless, and once it had become possible in principle (in some of the versions of sc2, I suspect it was introduced in 2.2.2 in order to be able to read files while playing sounds) it wasn’t even mentioned; over the following years it remained a repeated effort to keep this possibility alive, especially around 2001. This is how I realised that even wanting to code live isn’t that obvious after all.

The fact that running code could work like reading code (select and eval, and not compiling a whole file), made it possible to think of the GUI as obstruction for the interaction with a program (rather than the other way round). Because I was always late in preparing my code for the internet-radio broadcasts we did, I tended to program "on air”, though not “live". Being in a broadcast “studio”, half public, half hidden, made that possible. Giving workshops for other students together with Renate, teaching and experimenting with code provided a similar semi-official space. More than anything else, it was such exchange among friends that made it possible to really think in a certain way.

In the fluxus tradition of the art academy, there was a lot of conversational art with computers (e.g. email art), and happenings that involved any form of typography, text or chat was quite common. E.g. hypercard was used a lot. Projectors had just became affordable for the rather low budgets in this field, and projection was associated with art, so projecting code in public spaces certainly fell within the established paradigm. Nevertheless at that time, the stage was something one tended to try to overcome and to weaken, e.g. by participatory installations, or moving into a dark corner as a techno DJ. Virtuosity was rather suspicious. So to project code on stage, was after all not such an obvious thing to do, not so much because code was weird, but because the stage was weird. One of the reasons why hacking in nightclubs became important.

Please excuse the rather long ramblings. So I better leave out the philosophical and media-theoretical aspects here. So what was in the air? I suspect that it was a merge of cultures that led to a rather strange mix of expertise and ignorance, technical development and economy, made it possible exactly then. It had to be found out some time, after all. But I’m really curious to hear about more experiences ...
